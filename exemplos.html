<html>
	<head>
		<!-- Use the bootstrap as design reference -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
 		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="myscripts.js"></script>
 		<!-- Set character set to display latin characters -->
 		<meta charset="UTF-8">

 		<!-- Set author -->
 		 <meta name="author" content="Group 8">
 		 
 		<!-- Website title -->
		<title>Tutorial SPD</title>
	</head>

	<body>
		<!-- 
			Tópicos: Introdução, estrutura, narrativa, exemplos clássicos, erros (no meio da narrativa)
		-->
		<div class="container" style="width: 90%">
			<div class="row">
				<center>
					<div class="jumbotron">
						<!-- SECTION TITLE -->
						<h2>Exemplos clássicos</h2>
					</div>
				</center>
			</div>
			<div class="row">
				<!-- MAIN NAVIGATION TAB -->
				<div class="col-sm-2">
					<nav class="container-fluid">
						<ul class="nav navbar-nav">
							<li><a href="index.html">O que é o OpenMP?</a></li>
							<br>

							<li><a href="tudo_pronto.html">Tudo pronto?</a></li>
							<br>

							<li><a href="diretivas.html">Diretivas</a></li>
							<br>

							<li><a href="clausulas.html">Cláusulas</a></li>
							<br>

							<li><a href="execucao.html">Bibliotecas de execução</a></li>
							<br>

							<li><a href="variaveis.html">Variáveis de ambiente</a></li>
							<br>

							<li class="active"><a href="exemplos.html">Exemplos clássicos</a></li>
							<br>

							<li><a href="erros.html">Erros frequentes</a></li>
							<br>
						</ul>
					</nav>
				</div>
				<!-- SECTION CONTENT -->
				<div class="col-sm-14">
					<center><h3>Hello World</h3></center>
					<p>
						O hello world é utilizado como um exemplo clássico utilizado para introduzir programadores a uma linguagem de programação nova. Neste caso, pretende-se que todos os threads digam “Olá do thread “, seguido do id do thread.
					</p>
					<p>
						O código seguinte representa uma possível solução do problema:
					</p>
					<div class="container">
						<code>
							#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N 5                        // O número de threads

/* HELLO WORLD */
void hello_world() {
    // Cria uma região paralela que será percorrida por
    // N threads
    #pragma omp parallel num_threads(N)
    {
        // Inicializa a variável id, que representa o número do thread
        int id = omp_get_thread_num();

        // Para os olás aparecem organizados, os threads vão esperar
        // id segundos
        sleep(id);

        // Imprime o resultado no ecrã
        printf("Olá do thread %d\n", id);
    }
}

						</code>
					</div>

					<hr>

					<center><h3>Somatório</h3></center>
					<p>
						Neste exemplo, pretende-se que se efetue o somatório de 1 até um número n, dado pelo utilizador. O programa irá dividir a operação do somatório de forma igual pelos N threads. O programa irá irá possuir uma zona crítica, que será a soma do resultado pelo resultado do somatório dividido pelo thread.
					</p>
					<p>
						O código seguinte representa uma possível solução do problema:
					</p>
					<div class="container">
						<code>
							#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N 5                        // Número de threads

/* SOMATÓRIO */
/*
    Somatório individual de cada thread
*/
int sum_until(int min, int max) {
    int result = 0;
    for(int i = min; i <= max; i++)
        result += i;
    return result;
}


int somatorio(double n) {

    // Cria uma região paralela que será percorrida por
    // N threads
    #pragma omp parallel num_threads(N)
    {
        // Inicializa a variável id, que representa o número do thread
        int id = omp_get_thread_num();

        // Inicializa o mínimo e o máximo que o thread vai contar
        int min = id * n/N + 1;
        int max = (id+1) * n/N;
        printf("[%d] min = %d ; max = %d\n",id, min, max);
        // Como a obtenção do resultado é uma "mini" secção crítica,
        // foi declarada uma zona atómica, onde o resultado irá ser incrementado
        int sum = sum_until(min, max);
        #pragma omp atomic
            result = result + sum;
    }

    return result;
}
int main(int argc, char ** argv)
{
    int n = 0;
    printf("Valor: ");
    scanf("%d", &n);
    printf(“%d\n”, somatorio(n));
    return 0;
}

						</code>
					</div>

					<hr>

					<center><h3>Jantar dos filósofos</h3></center>
					<center><img src="img/img_4.png"></center>
					<p>
						O problema do jantar dos filósofos foi proposto por Dijkstra em 1965 como um problema clássico de sincronização, no qual consiste no seguinte problema:
					</p>
					<div class="container-fluid">
						<p>
							<i>
								N filósofos estão sentados ao redor de uma mesa circular para o jantar, onde cada filósofo possui um prato com comida para consumir utilizando pauzinhos, entre cada par de pratos existe apenas um pauzinho, ou seja, precisam de ser compartilhados de forma sincronizada. Quando comem, pegam apenas num pauzinho de cada vez, largando os pauzinhos imediatamente depois de comer. Por fim, os filósofos comem e pensam alternadamente, alternando entre estas duas atividades.
							</i>
						</p>
					</div>
					<p>
						O problema principal neste exercício consiste em coordenar o uso dos pauzinhos de maneira que nenhum filósofo fique com fome, evitando que ocorram deadlocks.
						O programa entra em deadlock quando todos os filósofos pegam no seu pauzinho da esquerda e ficam á espera pelo pauzinho direito (ocorrendo uma condição de espera circular).
					</p>
					<p>
						O programa seguinte representa uma possível solução do problema do jantar dos filósofos:
					</p>
					<div class="container">
						<code>
							#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N 5                        // O número de filósofos que irão comer
#define ROUNDS 3                   // O número de vezes que cada filósofo irá comer
static omp_lock_t chopsticks[N];   // Os pauzinhos são uma abstração dos locks

/* JANTAR DOS FILÓSOFOS */
/*  
    Esta função irá representar os threads. Cada filósofo deve esperar até todos os outros
    terem começado antes de continuar. Cada filósofo come um número de vezes igual á variável
    ROUNDS. Cada filósofo deve ter ambos os pauzinhos para poder comer.
 */
void filosofo()
{
  // Espera por todos os threads para começar
  #pragma omp barrier

  // Inicializa as variáveis id (o número do thread), o indicador do pauzinho direito e o
  // indicador do pauzinho esquerdo.
  int id = omp_get_thread_num();
  int right_chopstick;
  int left_chopstick;

  //  Os filósofos 0 até ao N-2 irão agarrar no pauzinho esquerdo (que se encontra na mesma
  //  posição do array) e no pauzinho direito (que se encontra uma posição á direita).
  if(id < N -1)
  {
    right_chopstick = id;
    left_chopstick = id+1;
  }

  //  O filósofo N-1 (o último filósofo) encontra-se numa situação especial, já que o garfo
  //  direito encontra-se na primeira posição do array.
  else
  {
    right_chopstick = 0;
    left_chopstick = id;
  }

  //  Efetua a ação do filósofo
  for(int i = 0; i < ROUNDS; i++)
  {
    // Agarra nos pauzinhos
    omp_set_lock(&chopsticks[left_chopstick]);
    omp_set_lock(&chopsticks[right_chopstick]);

    // Indica ao utilizador que está a comer
    printf("O filosofo %d come\n", id);

    // Espera 1 segundo
    sleep(1);

    // Larga os garfos
    omp_unset_lock(&chopsticks[left_chopstick]);
    omp_unset_lock(&chopsticks[right_chopstick]);
  }
}

/*
  Estabelece a situação inicial do jantar dos filósofos.
*/
void jantar_filosofos()
{
  int i;

  // Inicializa os locks
  for(i = 0; i < N; i++)
    omp_init_lock(&chopsticks[i]);

  //  Cria uma zona paralela que será percorrida por
  //  N filósofos (N threads). Cada filósofo irá correr
  //  a sua "versão" da função filosofo
  #pragma omp parallel num_threads(N)
  {
    filosofo();
  }

  // Espera que os filósofos acabem de comer para destruir
  // os locks.
  for(i = 0; i < N; i++)
    omp_destroy_lock(&chopsticks[i]);
}

						</code>
					</div>

					<hr>

					<center><h3>ATM</h3></center>
					<p>
						Ao longo do tutorial, foram mencionadas várias vezes secções do programa ATM.c. Este programa pretende simular as operações de levantamento e de depósito de N clientes ao mesmo tempo, onde o primeiro a anunciar a sua operação é o primeiro a efetuá-la e a atualizar a variável global dinheiro, que é o dinheiro presente na conta.
					</p>
					<p>
						O programa seguinte representa uma possível solução apresentada acima:
					</p>

					<div class="container">
						<code>
							//INCLUDES
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>

//VARIÁVEIS GLOBAIS
#define N 4
int dinheiro = 0;


//FUNÇÕES
char *str_dup(const char *s)
{
  char *result = (char *) malloc(strlen(s) + 1);
  strcpy(result, s);
  return result;
}

int str_readline(FILE *f, char *s)
{
  int result = EOF;
  char *p = fgets(s, INT_MAX, f);
  if (p != NULL)
  {
    result = (int) strlen(s);
    if (result > 0 && s[result-1] == '\n')
      s[--result] = '\0';
  }
  return result;
}


void deposito(int m) {
    #pragma omp atomic
        dinheiro = dinheiro + m;
}

void levantamento(int m) {
    #pragma omp atomic
        dinheiro = dinheiro - m;
}

/*
    Simula o comportamento de um cliente.
*/
void cliente(int id) {
    int action = 0;
    char resposta[20];
    int quantia = 0;
    // Declara esta secção como uma zona crítica onde
    // apenas pode ser interpretada por um thread de
    // cada vez.
    #pragma omp critical (decision)
    {
        while(action == 0) {
            printf("[%d] Deposito ou levantamento? ", id);
            str_readline(stdin, resposta);
            if(strcmp(resposta, "deposito") == 0) {
                action = 1;
                printf("Quantia: ");
                scanf("%d", &quantia);
            }
            else if(strcmp(resposta, "levantamento") == 0) {
                action = 2;
                printf("Quantia: ");
                scanf("%d", &quantia);
            }
        }
    }

    // Espera por todos os clientes para efetuarem todas
    // as ações ao mesmo tempo
    #pragma omp critical (transacao)
    {
        // Se o cliente avisou que queria fazer um depósito, irá
        // Efetuar um depósito. Os clientes que pretendem efetuar
        // um depósito têm prioridade sobre os que pretendem
        // levantar.
        if(action == 1) {
            deposito(quantia);
            printf("[%d] %d foram depositados da sua conta.\nSaldo atual: %d\n", id, quantia, dinheiro);
        }

        // Se o cliente avisou que queria fazer um levantamento e
        // possui saldo suficiente na conta para o efetuar, então
        // irá efetuar um levantamento.
        else if(action == 2 && quantia <= dinheiro) {
        
            levantamento(quantia);
            printf("[%d] %d foram levantados da sua conta.\nSaldo atual: %d\n",id, quantia, dinheiro);
        }

        // Caso o utilizador não possua saldo suficiente, irá
        // avisar.
        else if(action == 2) {
            printf("[%d] ERRO: Saldo insuficiente.\n", id);
        }

        // Caso nenhuma das condições tenham sido atingidas, quer
        // dizer que algo no programa falhou.
        else {
            printf("[%d] ERRO\n", id);
        }
    }
}

//MAIN
int main() {

    printf("A estabelecer uma zona paralela para %d threads...\n", N);
    #pragma omp parallel num_threads(N)
    {
        int thread_id = omp_get_thread_num();
        cliente(thread_id);
    }
    return 0;
}
						</code>
					</div>
				</div>
			</div>
		</div>

	</body>
</html>